name: Build mod optimise v6

on:
  workflow_dispatch:
    inputs:
      release_tag:
        required: false
        type: string
      merge_prs:
        description: 'Comma-separated PR numbers to merge (e.g., "1,2,3" or "0" for none)'
        required: false
        default: ''
        type: string
        
      fetch_branches_from_other:
        description: 'Enter "username/repo branch" to fetch & merge, or 0 for none'
        required: false
        default: '0'
      merge_dns:
        description: 'merge DNS commit (0 = none)'
        required: false
        default: '0'  # Updated to support 16KB page alignment
        
 
jobs:
  build:
    runs-on: ubuntu-latest
    steps:

    - name: Checkout repository
      uses: actions/checkout@v6.0.0
      
    - name: Set Swap Space
      uses: pierotofy/set-swap-space@master
      with:
          swap-size-gb: 10
    
    - name: Set up Go
      uses: actions/setup-go@v6
      with:
          go-version: '1.26.0-rc.3'
          check-latest: true

    - name: Activate patched Go
      shell: bash
      run: |
       go version
    - name: Install gomobile
      run: |
        go install golang.org/x/mobile/cmd/gomobile@latest
    - name: Setup Android SDK
      uses: android-actions/setup-android@v3.2.0
      with:
        log-accepted-android-sdk-licenses: false
        cmdline-tools-version: '12266719'
        packages: 'platforms;android-35 build-tools;35.0.0 platform-tools'

    - name: Install NDK
      run: |
        echo "y" | $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager \
          --channel=0 \
          --install "ndk;28.2.13676358"
        echo "ANDROID_NDK_HOME=$ANDROID_HOME/ndk/28.2.13676358" >> $GITHUB_ENV


    - name: Verify 
      run: |
         which go
         which gomobile

    - name: Download xray-patches for BoringSSL
      run: |
        echo "üì• Downloading xray-patches for BoringSSL integration..."
        mkdir -p xray-patches
        
        # Use GitHub API to list files in the directory
        echo "Fetching patch list from GitHub..."
        PATCHES=$(curl -s "https://api.github.com/repos/halibiram/SimpleXray/contents/xray-patches" | grep -o '"name": "[^"]*\.patch"' | cut -d'"' -f4)
        
        if [ -z "$PATCHES" ]; then
          echo "‚ö†Ô∏è No patches found via API, trying alternative method..."
          # Fallback: try to download known patches or use raw URLs directly
          for file in boringssl.patch tls.patch crypto.patch; do
            curl -sL "https://raw.githubusercontent.com/halibiram/SimpleXray/main/xray-patches/$file" -o "xray-patches/$file" && echo "Downloaded: $file" || true
          done
        else
          for patch in $PATCHES; do
            echo "Downloading: $patch"
            curl -sL "https://raw.githubusercontent.com/halibiram/SimpleXray/main/xray-patches/$patch" -o "xray-patches/$patch"
            if [ -f "xray-patches/$patch" ] && [ -s "xray-patches/$patch" ]; then
              echo "‚úÖ Downloaded: $patch ($(wc -l < xray-patches/$patch) lines)"
            else
              echo "‚ùå Failed to download: $patch"
              rm -f "xray-patches/$patch"
            fi
          done
        fi
        
        echo "üìÇ Available patches:"
        ls -la xray-patches/

    - name: Build BoringSSL for Android
      run: |
        echo "üîß Building BoringSSL for Android ABIs..."
        
        # Clone BoringSSL
        git clone --depth=1 https://github.com/google/boringssl.git
        cd boringssl
        
        # Build for each ABI
        for ABI in "arm64-v8a" "armeabi-v7a" "x86_64"; do
          echo "üì¶ Building BoringSSL for $ABI..."
          
          # Setup per-ABI configuration
          case "$ABI" in
            arm64-v8a)
              CMAKE_ARCH="arm64-v8a"
              TOOLCHAIN="aarch64-linux-android24"
              ;;
            armeabi-v7a)
              CMAKE_ARCH="armeabi-v7a"
              TOOLCHAIN="armv7a-linux-androideabi24"
              ;;
            x86_64)
              CMAKE_ARCH="x86_64"
              TOOLCHAIN="x86_64-linux-android24"
              ;;
          esac
          
          TOOLCHAIN_DIR="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64"
          BUILD_DIR="build_$ABI"
          mkdir -p "$BUILD_DIR"
          cd "$BUILD_DIR"
          
          # Configure with CMake
          cmake .. \
            -DCMAKE_SYSTEM_NAME=Android \
            -DCMAKE_SYSTEM_VERSION=24 \
            -DCMAKE_ANDROID_ARCH_ABI=$CMAKE_ARCH \
            -DCMAKE_ANDROID_NDK=$ANDROID_NDK_HOME \
            -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake \
            -DCMAKE_BUILD_TYPE=Release \
            -DOPENSSL_SMALL=1 \
            -DOPENSSL_NO_DEPRECATED=1 \
            -DBUILD_SHARED_LIBS=OFF \
            -GNinja
          
          # Build
          ninja -j$(nproc)
          
          # Verify
          if [ ! -f "crypto/libcrypto.a" ] || [ ! -f "ssl/libssl.a" ]; then
            echo "‚ùå BoringSSL build failed for $ABI"
            exit 1
          fi
          
          echo "‚úÖ BoringSSL built for $ABI"
          ls -lh crypto/libcrypto.a ssl/libssl.a
          
          cd ..
        done
        
        # Export paths for later steps
        echo "BORINGSSL_DIR=$(pwd)" >> $GITHUB_ENV
        cd ..

    - name: Build
      run: |
        mkdir -p assets data
        bash gen_assets.sh download
        cp -v data/*.dat assets/
        echo "Preparing Go environment..."
        go env -w GOPRIVATE=github.com/xtls/xray-core
        go env -w GONOSUMDB=github.com/xtls/xray-core

        echo "Finding Go module cache path..."
        MODCACHE=$(go env GOMODCACHE)
        echo "Module cache path: $MODCACHE"

        echo "Ensuring xray-core is a full git clone..."
        MOD_PATH="$MODCACHE/github.com/xtls/xray-core"
        rm -rf "$MOD_PATH"  # Remove any proxy-downloaded copy
        XRAY_PATH="$GITHUB_WORKSPACE/_deps/xray-core"
        rm -rf "$XRAY_PATH"
        
        git clone https://github.com/xtls/xray-core.git "$XRAY_PATH"
        cd "$XRAY_PATH"
        git checkout main

        echo "Fetching latest refs from origin..."
        git fetch origin main

        LOCAL_SHA=$(git rev-parse HEAD)
        REMOTE_SHA=$(git rev-parse origin/main)

        echo "Local HEAD:   $LOCAL_SHA"
        echo "Origin/main: $REMOTE_SHA"

        if [ "$LOCAL_SHA" = "$REMOTE_SHA" ]; then
         echo "‚úÖ xray-core is up to date with origin/main"
        else
         echo "‚ö†Ô∏è xray-core is NOT at latest origin/main"
         git log --oneline --decorate --max-count=5 origin/main
        fi
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        if [ "${{ github.event.inputs.merge_dns }}" != "0" ]; then
         DNS_MSG="refactor(dns): streamline query handling and remove redundant deadline logic"

         git remote add j2rong4cn https://github.com/j2rong4cn/Xray-core.git
         git fetch j2rong4cn main

         DNS_HOST_SHA=$(git log j2rong4cn/main --grep="$DNS_MSG" --format="%H" -n 1)

         if [ -n "$DNS_HOST_SHA" ]; then
          echo "Found commit: $DNS_HOST_SHA"
          git cherry-pick "$DNS_HOST_SHA" || true
         else
          echo "$DNS_MSG"
         fi
        fi
       
        
        COUNT=${{ github.event.inputs.pr_count }}
        IFS=',' read -ra PR_LIST <<< "${{ github.event.inputs.merge_prs }}"
          for PR_NUM in "${PR_LIST[@]}"; do
            echo "Fetching PR #$PR_NUM..."
            git fetch origin pull/$PR_NUM/head:pr-$PR_NUM
            echo "Merging PR #$PR_NUM (auto-resolve: theirs)..."
            git merge -X theirs --no-edit pr-$PR_NUM || true
            echo "Changes from PR #$PR_NUM:"
            git log HEAD~1..HEAD --stat || true
          done

        # Merge branch from   repo if requested
        if [ "${{ github.event.inputs.fetch_branches_from_other }}" != "0" ]; then
         BRANCH_INPUT="${{ github.event.inputs.fetch_branches_from_other }}"
        fi
        if [[ "$BRANCH_INPUT" != "0" ]]; then
        IFS=',' read -ra EXT_LIST <<< "$BRANCH_INPUT"
         for ITEM in "${EXT_LIST[@]}"; do
         REPO=$(echo "$ITEM" | awk '{print $1}')
         BRANCH=$(echo "$ITEM" | awk '{print $2}')

        echo "Fetching branch '$BRANCH' from repo '$REPO'..."

        # Name remote based on repo to avoid collision
        REMOTE_NAME="ext_$(echo "$REPO" | sed 's|/|_|g')"

        git remote add "$REMOTE_NAME" "https://github.com/$REPO.git" || true
        git fetch "$REMOTE_NAME" "$BRANCH"

        echo "Merging $REMOTE_NAME/$BRANCH (auto-resolve theirs)..."
        git merge -X theirs --no-edit "$REMOTE_NAME/$BRANCH" || true

        git add -A
        echo "Changes from $REMOTE_NAME/$BRANCH:"
        git log HEAD~1..HEAD --stat || true

        done
        fi          
                
        # Apply BoringSSL patches
        echo "üìù Applying BoringSSL patches to Xray-core..."
        if [ -d "$GITHUB_WORKSPACE/xray-patches" ]; then
          PATCH_COUNT=$(ls -1 $GITHUB_WORKSPACE/xray-patches/*.patch 2>/dev/null | wc -l)
          echo "Found $PATCH_COUNT patch files"
          
          for patch in $GITHUB_WORKSPACE/xray-patches/*.patch; do
            if [ -f "$patch" ]; then
              echo "  Applying: $(basename $patch)"
              if git apply --check "$patch" 2>/dev/null; then
                git apply "$patch" && echo "    ‚úÖ Applied successfully" || echo "    ‚ùå Apply failed"
              else
                echo "    ‚ö†Ô∏è  Patch $(basename $patch) cannot be applied cleanly (may already be applied or incompatible)"
                git apply "$patch" || true
              fi
            fi
          done
        else
          echo "‚ö†Ô∏è  No xray-patches directory found"
        fi
        
        wget https://raw.githubusercontent.com/t-e-s-tweb/v-rules/refs/heads/main/xmuxpatch.sh
        bash xmuxpatch.sh
        cd ${{ github.workspace }}/

        echo "Updating go.mod to use local xray-core..."
        go mod edit -replace=github.com/xtls/xray-core="$XRAY_PATH"
        #go mod edit -replace=gvisor.dev/gvisor=gvisor.dev/gvisor@v0.0.0-20260109181451-4be7c433dae2

        #go mod edit -replace=gvisor.dev/gvisor=gvisor.dev/gvisor@v0.0.0-20250606001031-fa4c4dd86b43
          
        # Update specific dependency
        #go get github.com/xtls/xray-core@${{ env.LATEST_TAG_SHA }}

        # Update all other dependencies
        
        
        go get golang.org/x/mobile@latest
        go mod tidy
        go mod download
        

        
        
        echo "Binding for Android..."
        # Export parallel compilation (uses all CPU cores for faster builds)
        export GOMAXPROCS=$(nproc)
        export CGO_ENABLED=1
        export GOEXPERIMENT="runtimefreegc,sizespecializedmalloc,greenteagc,jsonv2,newinliner,heapminimum512kib"
        echo "Initializing gomobile..."
        gomobile init -v
        go mod tidy


       
        export CC="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang"
        export CXX="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang++"
        export CGO_CFLAGS="-O3 -fvisibility=hidden -ffunction-sections -fdata-sections -fomit-frame-pointer -I${{ env.BORINGSSL_DIR }}/include"
        export CGO_CXXFLAGS="-O3 -fvisibility=hidden -ffunction-sections -fdata-sections -fomit-frame-pointer -I${{ env.BORINGSSL_DIR }}/include"

        # Link BoringSSL static libraries for arm64-v8a (primary target)
        export CGO_LDFLAGS="-L${{ env.BORINGSSL_DIR }}/build_arm64-v8a -lcrypto -lssl -Wl,-z,max-page-size=16384 -Wl,-z,common-page-size=16384 -Wl,-z,separate-loadable-segments -Wl,-z,now -Wl,--gc-sections -Wl,--strip-all"
        
        echo "=== BUILD ENV ==="
        echo "GOOS=$GOOS"
        echo "GOARCH=$GOARCH"
        echo "CC=$CC"
        echo "CGO_CFLAGS=$CGO_CFLAGS"
        echo "CGO_LDFLAGS=$CGO_LDFLAGS"
        go env GOOS GOARCH CC CGO_CFLAGS
        echo "=================="
        gomobile bind -v -x -androidapi 24 -trimpath -gcflags="all=-l=4" -ldflags="-s -w -linkmode=external" ./
  
        
        #export CGO_LDFLAGS="-fuse-ld=lld -Wl,-z,separate-loadable-segments -Wl,-z,common-page-size=0x4000 -Wl,-z,max-page-size=0x4000 -Wl,--strip-all -Wl,--gc-sections"
        #gomobile bind -v -x -androidapi 24 -trimpath -gcflags="all=-l=4" \
        #-ldflags="-s -w -buildid='' -linkmode external -extldflags='-Wl,-z,now -Wl,-z,separate-loadable-segments -Wl,-z,common-page-size=0x4000 -Wl,-z,max-page-size=0x4000 -Wl,--strip-all -Wl,--gc-sections'" \
        #./
        #gomobile bind -androidapi 24 -trimpath -gcflags="all=-l=4" \
        #-ldflags="-s -w -buildid='' -linkmode external -extldflags=-Wl,-z,now,-Wl,-z,separate-loadable-segments,-Wl,-z,common-page-size=0x4000,-Wl,-z,max-page-size=0x4000,-Wl,--strip-all,-Wl,--gc-sections" \
        #./

        #gomobile bind -v -x -androidapi 24 -trimpath -gcflags="all=-l=4" -ldflags="-s -w -buildid='' -linkmode external -extldflags=\"$CGO_LDFLAGS\"" ./

        #gomobile bind -v -x -androidapi 24 -trimpath -gcflags="all=-l=4" -ldflags="-s -w -buildid='' -linkmode external -extldflags=$CGO_LDFLAGS" ./
  

    - name: Strip native libraries in AAR
      run: |
       # Setup paths
        AAR_FILE="libv2ray.aar"
        EXTRACT_DIR="aar_extract"
        NDK_STRIP="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
    
        # Verify AAR exists
       if [ ! -f "$AAR_FILE" ]; then
        echo "Error: $AAR_FILE not found!"
        exit 1
       fi
    
       # Create extraction directory
       mkdir -p "$EXTRACT_DIR"
    
       # Extract AAR (it's just a ZIP)
       echo "Extracting $AAR_FILE..."
       unzip -q "$AAR_FILE" -d "$EXTRACT_DIR"
    
       # Find and strip all .so files
       echo "Stripping native libraries..."
       find "$EXTRACT_DIR" -name "*.so" -type f | while read -r so_file; do
       arch=$(basename "$(dirname "$so_file")")
       echo "  Processing [$arch]: $(basename "$so_file")"
      
       # Get size before
       size_before=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null)
      
       # Strip: --strip-all removes all symbols (same as -s)
       "$NDK_STRIP" --strip-all "$so_file"
      
       # Get size after
       size_after=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null)
       saved=$((size_before - size_after))
      
       echo "    Saved: $saved bytes ($(numfmt --to=iec $saved 2>/dev/null || echo "$saved"))"
       done
    
       # Repackage AAR with maximum compression
       echo "Repackaging AAR..."
       cd "$EXTRACT_DIR"
     
       # Create new AAR with optimized compression
       # -X: no extra file attributes (cleaner)
       # -9: maximum compression
       zip -r -X -9 "../${AAR_FILE}.tmp" .
       cd ..
    
       # Replace original
       mv "${AAR_FILE}.tmp" "$AAR_FILE"
    
       # Cleanup
       rm -rf "$EXTRACT_DIR"
    
       # Show final result
       echo "Post-strip AAR size: $(ls -lh $AAR_FILE | awk '{print $5}')"


    - name: Upload build artifacts
      if: github.event.inputs.release_tag == ''
      uses: actions/upload-artifact@v6.0.0
      with:
        name: libv2ray
        path: |
          ${{ github.workspace }}/libv2ray*r

    - name: Upload AndroidLibXrayLite to release
      if: github.event.inputs.release_tag != ''
      uses: svenstaro/upload-release-action@v2
      with:
        file: ./libv2ray*r
        tag: ${{ github.event.inputs.release_tag }}
        file_glob: true
        overwrite: true
