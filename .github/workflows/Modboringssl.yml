name: Build mod optimise v6 boringssl

on:
  workflow_dispatch:
    inputs:
      release_tag:
        required: false
        type: string
      merge_prs:
        description: 'Comma-separated PR numbers to merge (e.g., "1,2,3" or "0" for none)'
        required: false
        default: ''
        type: string
        
      fetch_branches_from_other:
        description: 'Enter "username/repo branch" to fetch & merge, or 0 for none'
        required: false
        default: '0'
      merge_dns:
        description: 'merge DNS commit (0 = none)'
        required: false
        default: '0'
        
 
jobs:
  build:
    runs-on: ubuntu-latest
    steps:

    - name: Checkout repository
      uses: actions/checkout@v6.0.0
      with:
        submodules: false
      
    - name: Set Swap Space
      uses: pierotofy/set-swap-space@master
      with:
          swap-size-gb: 10
    
    - name: Set up Go
      uses: actions/setup-go@v6
      with:
          go-version: '1.26.0-rc.3'
          check-latest: true

    - name: Activate patched Go
      shell: bash
      run: |
       go version
       
    - name: Install gomobile
      run: |
        go install golang.org/x/mobile/cmd/gomobile@latest
        
    - name: Setup Android SDK
      uses: android-actions/setup-android@v3.2.0
      with:
        log-accepted-android-sdk-licenses: false
        cmdline-tools-version: '12266719'
        packages: 'platforms;android-35 build-tools;35.0.0 platform-tools'

    - name: Install NDK
      run: |
        echo "y" | $ANDROID_HOME/cmdline-tools/latest/bin/sdkmanager \
          --channel=0 \
          --install "ndk;28.2.13676358"
        echo "ANDROID_NDK_HOME=$ANDROID_HOME/ndk/28.2.13676358" >> $GITHUB_ENV

    - name: Setup BoringSSL Source
      run: |
        echo "üîß Setting up BoringSSL for local development..."
        
        BORINGSSL_DIR="app/src/main/jni/perf-net/third_party/boringssl"
        
        # Check if BoringSSL is already initialized
        if [ -d "$BORINGSSL_DIR" ] && [ -f "$BORINGSSL_DIR/CMakeLists.txt" ]; then
            echo "‚úÖ BoringSSL source already exists at $BORINGSSL_DIR"
        
            # Verify headers are present
            if [ -f "$BORINGSSL_DIR/include/openssl/ssl.h" ]; then
                echo "‚úÖ BoringSSL headers verified"
        
                # Get commit hash for reference
                cd "$BORINGSSL_DIR"
                COMMIT=$(git rev-parse HEAD | cut -c 1-12)
                echo "üìå BoringSSL commit: $COMMIT"
                cd - > /dev/null
        
                echo ""
                echo "BoringSSL is ready for use!"
                exit 0
            else
                echo "‚ö†Ô∏è  BoringSSL source exists but headers are missing"
                echo "   Reinitializing submodule..."
            fi
        fi
        
        # Initialize BoringSSL as a git submodule
        echo "üì¶ Initializing BoringSSL submodule..."
        echo "   This may take a few minutes..."
        
        # First, make sure submodule is registered
        if ! git config -f .gitmodules --get submodule.app/src/main/jni/perf-net/third_party/boringssl.url > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  BoringSSL submodule not found in .gitmodules"
            echo "   Adding BoringSSL as a submodule..."
        
            # Remove directory if it exists but is not a proper submodule
            if [ -d "$BORINGSSL_DIR" ]; then
                rm -rf "$BORINGSSL_DIR"
            fi
        
            # Add as submodule
            git submodule add --force https://boringssl.googlesource.com/boringssl "$BORINGSSL_DIR" || {
                echo "‚ö†Ô∏è  Failed to add from googlesource, trying GitHub mirror..."
                git submodule add --force https://github.com/google/boringssl.git "$BORINGSSL_DIR" || {
                    echo "‚ùå Failed to add BoringSSL submodule"
                    exit 1
                }
            }
        fi
        
        # Initialize and update the submodule
        if git submodule update --init --depth 1 "$BORINGSSL_DIR" 2>&1; then
            echo "‚úÖ BoringSSL submodule initialized successfully"
        else
            echo "‚ö†Ô∏è  Submodule init failed, trying alternative method..."
        
            # Try without depth limitation
            if git submodule update --init "$BORINGSSL_DIR" 2>&1; then
                echo "‚úÖ BoringSSL submodule initialized successfully"
            else
                echo "‚ùå Failed to initialize BoringSSL submodule"
                echo "   Please check your internet connection and try again"
                exit 1
            fi
        fi
        
        # Verify CMakeLists.txt exists
        if [ ! -f "$BORINGSSL_DIR/CMakeLists.txt" ]; then
            echo "‚ùå BoringSSL CMakeLists.txt not found after initialization!"
            echo "   This indicates an incomplete or corrupted clone"
            exit 1
        fi
        
        # Verify headers exist
        if [ ! -f "$BORINGSSL_DIR/include/openssl/ssl.h" ]; then
            echo "‚ùå BoringSSL headers not found after initialization!"
            echo "   This indicates an incomplete or corrupted clone"
            exit 1
        fi
        
        # Get commit hash for reference
        cd "$BORINGSSL_DIR"
        COMMIT=$(git rev-parse HEAD | cut -c 1-12)
        echo "‚úÖ BoringSSL pinned to commit: $COMMIT"
        cd - > /dev/null
        
        echo ""
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "‚úÖ BoringSSL Setup Complete!"
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    - name: Build BoringSSL
      run: |
        echo "üîß Building BoringSSL for arm64-v8a..."
        
        ABI="arm64-v8a"
        NDK_HOME="$ANDROID_NDK_HOME"
        
        # ABI configuration
        TOOLCHAIN="aarch64-linux-android24"
        CMAKE_ARCH="arm64-v8a"
        
        echo "NDK: $NDK_HOME"
        echo "Toolchain: $TOOLCHAIN"
        echo "‚úÖ Detected ARM64 with crypto extensions support"
        
        # Find BoringSSL directory
        BORINGSSL_DIR="app/src/main/jni/perf-net/third_party/boringssl"
        if [ ! -d "$BORINGSSL_DIR" ]; then
            echo "‚ùå BoringSSL directory not found: $BORINGSSL_DIR"
            exit 1
        fi
        
        cd "$BORINGSSL_DIR"
        
        # Setup toolchain
        TOOLCHAIN_DIR="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64"
        export PATH=$TOOLCHAIN_DIR/bin:$PATH
        export CC=$TOOLCHAIN_DIR/bin/$TOOLCHAIN-clang
        export CXX=$TOOLCHAIN_DIR/bin/$TOOLCHAIN-clang++
        export AR=$TOOLCHAIN_DIR/bin/llvm-ar
        export RANLIB=$TOOLCHAIN_DIR/bin/llvm-ranlib
        export STRIP=$TOOLCHAIN_DIR/bin/llvm-strip
        export ANDROID_NDK_HOME=$NDK_HOME
        export ANDROID_NDK_ROOT=$NDK_HOME
        
        # Create build directory
        BUILD_DIR="build_$ABI"
        mkdir -p "$BUILD_DIR"
        cd "$BUILD_DIR"
        
        # Configure BoringSSL with CMake (disable benchmarks to avoid build errors)
        echo "üì¶ Configuring BoringSSL with CMake..."
        cmake .. \
            -DCMAKE_SYSTEM_NAME=Android \
            -DCMAKE_SYSTEM_VERSION=24 \
            -DCMAKE_ANDROID_ARCH_ABI=$CMAKE_ARCH \
            -DCMAKE_ANDROID_NDK=$NDK_HOME \
            -DCMAKE_TOOLCHAIN_FILE=$NDK_HOME/build/cmake/android.toolchain.cmake \
            -DCMAKE_BUILD_TYPE=Release \
            -DOPENSSL_SMALL=1 \
            -DOPENSSL_NO_DEPRECATED=1 \
            -DOPENSSL_NO_ASM=0 \
            -DBUILD_SHARED_LIBS=OFF \
            -DBENCHMARK_ENABLE_TESTING=OFF \
            -DBENCHMARK_ENABLE_INSTALL=OFF \
            -DBENCHMARK_ENABLE_GTEST_TESTS=OFF \
            -GNinja

        
        # Build only crypto and ssl (skip benchmarks and tests)
        echo "üî® Building BoringSSL..."
        ninja -j$(nproc) crypto ssl

        
        # Verify build
        if [ -f "crypto/libcrypto.a" ] && [ -f "ssl/libssl.a" ]; then
            echo "‚úÖ BoringSSL build complete for $ABI"
            echo "üì¶ Libraries:"
            ls -lh crypto/libcrypto.a ssl/libssl.a
        else
            echo "‚ùå Build failed - libraries not found"
            exit 1
        fi
        
        # Save paths for later steps
        echo "BORINGSSL_CRYPTO=$(realpath crypto/libcrypto.a)" >> $GITHUB_ENV
        echo "BORINGSSL_SSL=$(realpath ssl/libssl.a)" >> $GITHUB_ENV
        echo "BORINGSSL_INCLUDE=$(realpath ../include)" >> $GITHUB_ENV
        
        cd ${{ github.workspace }}

    - name: Download xray-patches
      run: |
        echo "üì• Downloading xray-patches for BoringSSL integration..."
        mkdir -p xray-patches
        
        # Use GitHub API to list files in the directory
        PATCHES=$(curl -s "https://api.github.com/repos/halibiram/SimpleXray/contents/xray-patches" | grep -o '"name": "[^"]*\.patch"' | cut -d'"' -f4)
        
        for patch in $PATCHES; do
          echo "Downloading: $patch"
          curl -sL "https://raw.githubusercontent.com/halibiram/SimpleXray/main/xray-patches/$patch" -o "xray-patches/$patch"
        done
        
        echo "üìÇ Available patches:"
        ls -la xray-patches/

    - name: Build Xray with Gomobile
      run: |
        mkdir -p assets data
        bash gen_assets.sh download
        cp -v data/*.dat assets/
        echo "Preparing Go environment..."
        go env -w GOPRIVATE=github.com/xtls/xray-core
        go env -w GONOSUMDB=github.com/xtls/xray-core

        echo "Finding Go module cache path..."
        MODCACHE=$(go env GOMODCACHE)
        echo "Module cache path: $MODCACHE"

        echo "Ensuring xray-core is a full git clone..."
        MOD_PATH="$MODCACHE/github.com/xtls/xray-core"
        rm -rf "$MOD_PATH"
        XRAY_PATH="$GITHUB_WORKSPACE/_deps/xray-core"
        rm -rf "$XRAY_PATH"
        
        git clone https://github.com/xtls/xray-core.git "$XRAY_PATH"
        cd "$XRAY_PATH"
        git checkout main

        echo "Fetching latest refs from origin..."
        git fetch origin main

        LOCAL_SHA=$(git rev-parse HEAD)
        REMOTE_SHA=$(git rev-parse origin/main)

        echo "Local HEAD:   $LOCAL_SHA"
        echo "Origin/main: $REMOTE_SHA"

        if [ "$LOCAL_SHA" = "$REMOTE_SHA" ]; then
         echo "‚úÖ xray-core is up to date with origin/main"
        else
         echo "‚ö†Ô∏è xray-core is NOT at latest origin/main"
         git log --oneline --decorate --max-count=5 origin/main
        fi
        
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

        if [ "${{ github.event.inputs.merge_dns }}" != "0" ]; then
         DNS_MSG="refactor(dns): streamline query handling and remove redundant deadline logic"
         git remote add j2rong4cn https://github.com/j2rong4cn/Xray-core.git
         git fetch j2rong4cn main
         DNS_HOST_SHA=$(git log j2rong4cn/main --grep="$DNS_MSG" --format="%H" -n 1)

         if [ -n "$DNS_HOST_SHA" ]; then
          echo "Found commit: $DNS_HOST_SHA"
          git cherry-pick "$DNS_HOST_SHA" || true
         fi
        fi
       
        # Merge PRs if requested
        IFS=',' read -ra PR_LIST <<< "${{ github.event.inputs.merge_prs }}"
        for PR_NUM in "${PR_LIST[@]}"; do
          if [ "$PR_NUM" != "0" ] && [ -n "$PR_NUM" ]; then
            echo "Fetching PR #$PR_NUM..."
            git fetch origin pull/$PR_NUM/head:pr-$PR_NUM
            echo "Merging PR #$PR_NUM..."
            git merge -X theirs --no-edit pr-$PR_NUM || true
          fi
        done

        # Merge branch from other repo if requested
        if [ "${{ github.event.inputs.fetch_branches_from_other }}" != "0" ]; then
          BRANCH_INPUT="${{ github.event.inputs.fetch_branches_from_other }}"
          IFS=',' read -ra EXT_LIST <<< "$BRANCH_INPUT"
          for ITEM in "${EXT_LIST[@]}"; do
            REPO=$(echo "$ITEM" | awk '{print $1}')
            BRANCH=$(echo "$ITEM" | awk '{print $2}')
            echo "Fetching branch '$BRANCH' from repo '$REPO'..."
            REMOTE_NAME="ext_$(echo "$REPO" | sed 's|/|_|g')"
            git remote add "$REMOTE_NAME" "https://github.com/$REPO.git" || true
            git fetch "$REMOTE_NAME" "$BRANCH"
            git merge -X theirs --no-edit "$REMOTE_NAME/$BRANCH" || true
          done
        fi          
                
        # Apply BoringSSL patches
        echo "üìù Applying BoringSSL patches to Xray-core..."
        if [ -d "$GITHUB_WORKSPACE/xray-patches" ]; then
          for patch in $GITHUB_WORKSPACE/xray-patches/*.patch; do
            if [ -f "$patch" ]; then
              echo "  Applying: $(basename $patch)"
              if git apply --check "$patch" 2>/dev/null; then
                git apply "$patch" && echo "    ‚úÖ Applied" || echo "    ‚ùå Failed"
              else
                echo "    ‚ö†Ô∏è  Cannot apply cleanly, trying 3-way merge..."
                git apply --3way "$patch" || true
              fi
            fi
          done
        fi
        
        # Apply xmux patch
        wget https://raw.githubusercontent.com/t-e-s-tweb/v-rules/refs/heads/main/xmuxpatch.sh
        bash xmuxpatch.sh
        
        cd ${{ github.workspace }}/

        echo "Updating go.mod to use local xray-core..."
        go mod edit -replace=github.com/xtls/xray-core="$XRAY_PATH"
        go get golang.org/x/mobile@latest
        go mod tidy
        go mod download

        echo "Binding for Android..."
        export GOMAXPROCS=$(nproc)
        export CGO_ENABLED=1
        export GOEXPERIMENT="runtimefreegc,sizespecializedmalloc,greenteagc,jsonv2,newinliner,heapminimum512kib"
        
        echo "Initializing gomobile..."
        gomobile init -v
        go mod tidy

        # Setup NDK paths
        NDK_TOOLCHAIN="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64"
        NDK_SYSROOT="$NDK_TOOLCHAIN/sysroot"
        
        # Verify BoringSSL env vars are set
        if [ -z "$BORINGSSL_CRYPTO" ] || [ -z "$BORINGSSL_SSL" ] || [ -z "$BORINGSSL_INCLUDE" ]; then
          echo "‚ùå BoringSSL environment variables not set!"
          echo "BORINGSSL_CRYPTO: $BORINGSSL_CRYPTO"
          echo "BORINGSSL_SSL: $BORINGSSL_SSL"
          echo "BORINGSSL_INCLUDE: $BORINGSSL_INCLUDE"
          exit 1
        fi
        
        echo "‚úÖ BoringSSL libraries:"
        ls -lh "$BORINGSSL_CRYPTO" "$BORINGSSL_SSL"
        echo "‚úÖ BoringSSL include: $BORINGSSL_INCLUDE"

        # Set compiler for arm64-v8a
        export CC="$NDK_TOOLCHAIN/bin/aarch64-linux-android24-clang"
        export CXX="$NDK_TOOLCHAIN/bin/aarch64-linux-android24-clang++"
        export AR="$NDK_TOOLCHAIN/bin/llvm-ar"
        export RANLIB="$NDK_TOOLCHAIN/bin/llvm-ranlib"
        
        # CGO flags with BoringSSL
        export CGO_CFLAGS="-O3 -fvisibility=hidden -ffunction-sections -fdata-sections -fomit-frame-pointer -I$BORINGSSL_INCLUDE --sysroot=$NDK_SYSROOT"
        export CGO_CXXFLAGS="-O3 -fvisibility=hidden -ffunction-sections -fdata-sections -fomit-frame-pointer -I$BORINGSSL_INCLUDE --sysroot=$NDK_SYSROOT"
        
        # Hybrid static/dynamic linking
        export CGO_LDFLAGS="\
          -Wl,-Bstatic \
          -L$(dirname $BORINGSSL_CRYPTO) -L$(dirname $BORINGSSL_SSL) \
          -lcrypto -lssl \
          -Wl,-Bdynamic \
          -L$NDK_SYSROOT/usr/lib/aarch64-linux-android/24 \
          -llog -landroid -lc -lm -ldl \
          --sysroot=$NDK_SYSROOT \
          -Wl,-z,max-page-size=16384 \
          -Wl,-z,common-page-size=16384 \
          -Wl,-z,separate-loadable-segments \
          -Wl,-z,now \
          -Wl,--gc-sections"

        echo "=== BUILD ENV ==="
        echo "GOOS=android"
        echo "GOARCH=arm64"
        echo "CC=$CC"
        echo "CGO_CFLAGS=$CGO_CFLAGS"
        echo "CGO_LDFLAGS=$CGO_LDFLAGS"
        echo "=================="
        
        # Build with gomobile
        gomobile bind -v -x -androidapi 24 -trimpath \
          -gcflags="all=-l=4" \
          -ldflags="-s -w -linkmode=external" \
          ./

    - name: Strip native libraries in AAR
      run: |
        AAR_FILE="libv2ray.aar"
        EXTRACT_DIR="aar_extract"
        NDK_STRIP="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-strip"
    
        if [ ! -f "$AAR_FILE" ]; then
          echo "Error: $AAR_FILE not found!"
          exit 1
        fi
    
        mkdir -p "$EXTRACT_DIR"
        unzip -q "$AAR_FILE" -d "$EXTRACT_DIR"
    
        echo "Stripping native libraries..."
        find "$EXTRACT_DIR" -name "*.so" -type f | while read -r so_file; do
          arch=$(basename "$(dirname "$so_file")")
          echo "  Processing [$arch]: $(basename "$so_file")"
          size_before=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null)
          "$NDK_STRIP" --strip-all "$so_file"
          size_after=$(stat -c%s "$so_file" 2>/dev/null || stat -f%z "$so_file" 2>/dev/null)
          saved=$((size_before - size_after))
          echo "    Saved: $saved bytes"
        done
    
        echo "Repackaging AAR..."
        cd "$EXTRACT_DIR"
        zip -r -X -9 "../${AAR_FILE}.tmp" .
        cd ..
        mv "${AAR_FILE}.tmp" "$AAR_FILE"
        rm -rf "$EXTRACT_DIR"
    
        echo "Post-strip AAR size: $(ls -lh $AAR_FILE | awk '{print $5}')"

    - name: Upload build artifacts
      if: github.event.inputs.release_tag == ''
      uses: actions/upload-artifact@v6.0.0
      with:
        name: libv2ray
        path: |
          ${{ github.workspace }}/libv2ray*r

    - name: Upload AndroidLibXrayLite to release
      if: github.event.inputs.release_tag != ''
      uses: svenstaro/upload-release-action@v2
      with:
        file: ./libv2ray*r
        tag: ${{ github.event.inputs.release_tag }}
        file_glob: true
        overwrite: true
